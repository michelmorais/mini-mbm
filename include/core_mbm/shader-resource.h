/*-----------------------------------------------------------------------------------------------------------------------|
| MIT License (MIT)                                                                                                      |
| Copyright (C) 2015      by Michel Braz de Morais  <michel.braz.morais@gmail.com>                                       |
|                                                                                                                        |
| Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated           |
| documentation files (the "Software"), to deal in the Software without restriction, including without limitation        |
| the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and       |
| to permit persons to whom the Software is furnished to do so, subject to the following conditions:                     |
|                                                                                                                        |
| The above copyright notice and this permission notice shall be included in all copies or substantial portions of       |
| the Software.                                                                                                          |
|                                                                                                                        |
| THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE   |
| WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR  |
| COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR       |
| OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.       |
|                                                                                                                        |
|-----------------------------------------------------------------------------------------------------------------------*/

#ifndef SHADER_RESOURCE_GLES_H
#define SHADER_RESOURCE_GLES_H

#include <stdio.h>

namespace mbm
{
    static const char *resourceShader[] = { // organizado de 3 em 3. sendo: Nome do arquivo, Código shader e configurações CFG.

    /* PIXEL SHADER
       -----------------------------------------------------------------------------------------------------*/
    "edge gradient magnitude.ps",

    "precision mediump float;\n"
    "uniform vec2 imageSize;\n"
    "uniform sampler2D sample0;\n"
    "uniform float tolerance;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main( in vec2 uv) \n"
    "{\n"
    "    vec2 offsetTexture;\n"
    "    vec2 pixel_Right;\n"
    "    vec2 pixel_Left;\n"
    "    vec2 pixel_Top;\n"
    "    vec2 pixel_Bottom;\n"
    "    vec2 gradient;\n"
    "    float a;\n"
    "\n"
    "    offsetTexture = (1.00000 / imageSize);\n"
    "    pixel_Right = (uv.xy  + vec2( offsetTexture.x , 0.000000));\n"
    "    pixel_Left = (uv.xy  + vec2( ( -offsetTexture.x  ), 0.000000));\n"
    "    pixel_Top = (uv.xy  + vec2( 0.000000, offsetTexture.y ));\n"
    "    pixel_Bottom = (uv.xy  + vec2( 0.000000, ( -offsetTexture.y  )));\n"
    "    gradient = vec2( length( (texture2D( sample0, pixel_Right).xyz  - texture2D( sample0, pixel_Left).xyz ) ), length( (texture2D( sample0, pixel_Top).xyz  - texture2D( sample0, pixel_Bottom).xyz ) ));\n"
    "    a = length( gradient );\n"
    "    return vec4( a, a, a, 1.00000);\n"
    "}\n"
    "\n"
    "void main() \n"
    "{\n"
    "   float a = texture2D(sample0, vTexCoord).a;\n"
    "   if (a == 0.0)\n"
    "       discard;\n"
    "    else\n"
    "    {\n"
    "        vec4 color = xlat_main(vTexCoord);\n"
    "        if(color.r <= tolerance && color.g <= tolerance && color.b <= tolerance)\n"
    "           discard;\n"
    "        else\n"
    "           gl_FragColor = xlat_main(vTexCoord);\n"
    "    }"
    "}\n",

    "[edge-gradient-magnitude.ps] = edge gradient magnitude.ps\n"
    "[edge-gradient-magnitude.ps][vector2][imageSize] = min 0 0 max 1024 1024 default 256 256 \n"
    "[edge-gradient-magnitude.ps][float][tolerance] = min 0.0 max 1.0 default 0.0 \n",

    // gaussian *********************

    "explosion gaussian.ps",

    "precision mediump float;\n"
    "uniform sampler2D sample0;\n"
    "uniform vec2 center;\n"
    "uniform vec3 color;\n"
    "uniform float sigma;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main( in vec2 uv ) \n"
    "{\n"
    "    float alpha;\n"
    "    float PI = 3.14152;\n"
    "    float s;\n"
    "    float q;\n"
    "    float a;\n"
    "\n"
    "    s = (2.0 * pow( sigma, 2.0));\n"
    "    q = (1.0 / (PI * s));\n"
    "    a = (q * exp( (( -(pow( (uv.x  - center.x), 2.0) + pow( (uv.y  - center.y), 2.0)) ) / s) ));\n"
    "    alpha = texture2D(sample0, uv.xy).a;\n"
    "    return vec4( a * color.r, a * color.g, a * color.b, alpha);\n"
    "}\n"
    "\n"
    "\n"
    "void main() \n"
    "{\n"
    "    gl_FragColor = xlat_main( vTexCoord);\n"
    "}\n",

    "[ps-explosion-gaussian.ps] = explosion gaussian.ps\n"
    "[ps-explosion-gaussian.ps][float][sigma] = min -2.0 max 2.0 default 0.15 \n"
    "[ps-explosion-gaussian.ps][vector2][center] = min -1.0 -1.0 max 1.5 1.5 default 0.5 0.5 \n"
    "[ps-explosion-gaussian.ps][rgb][color]  = min 0.0 0.0 0.0 max 1.0 1.0 1.0 default 1.0 1.0 1.0 \n",

    // luminance *********************

    "luminance.ps",

    "precision mediump float;\n"
    "uniform vec4 color;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main( in vec2 uv ) \n"
    "{\n"
    "    vec4 texColor;\n"
    "    float luminance;\n"
    "    vec4 xlat_var_output;\n"
    "    vec4 white = vec4( 1.00000, 1.00000, 1.00000, 1.00000);\n"
    "\n"
    "    texColor = texture2D( sample0, uv);\n"
    "    luminance = dot( texColor, vec4( 0.212600, 0.715200, 0.0722000, 0.000000));\n"
    "    xlat_var_output = vec4( 0.000000);\n"
    "    if ( (luminance < 0.500000) ){\n"
    "        xlat_var_output = ((2.00000 * texColor) * color);\n"
    "    }\n"
    "    else{\n"
    "        xlat_var_output = (white - ((2.00000 * (white - texColor)) * (white - color)));\n"
    "    }\n"
    "    xlat_var_output.w  = (texColor.w  * color.w );\n"
    "    return xlat_var_output;\n"
    "}\n"
    "\n"
    "void main() \n"
    "{\n"
    "    gl_FragColor = xlat_main( vTexCoord);\n"
    "}",

    "[luminance.ps] = luminance.ps\n"
    "[luminance.ps][rgba][color] = min 0 0 0 0 max 1.0 1.0 1.0 1.0 default 0.5 0.5 0.5 0.5 \n",


    // blend *********************
    "blend.ps",

    "precision mediump float;\n"
    "uniform vec3 colorAdd;\n"
    "uniform vec4 junctionRemove;\n"
    "uniform sampler2D sample0;\n"
    "uniform sampler2D sample1;\n"
    "uniform float invertSample;\n"
    "uniform float disableSample1;\n\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "void main() \n"
    "{\n"
    "    vec4 c0;\n"
    "    vec4 c1;\n"
    "    vec4 original;\n"
    "    vec4 outColor;\n"
    "\n"
    "   if (invertSample > 0.5)\n"
    "   {\n"
    "       c0 = texture2D(sample1, vTexCoord.xy);//sample1 precisa ter alpha\n"
    "       c1 = texture2D(sample0, vTexCoord.xy);//sample0 nao precisa ter alpha\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       c0 = texture2D(sample0, vTexCoord.xy);//sample0 nao precisa ter alpha\n"
    "       c1 = texture2D(sample1, vTexCoord.xy);//sample1 precisa ter alpha\n"
    "   }\n"
    "   if(disableSample1 > 0.5)\n"
    "   {\n"
    "       c0.rgb += colorAdd;\n"
    "       gl_FragColor = c0;\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       c1 -= junctionRemove;\n"
    "       original = c0;\n"
    "       outColor.w  = c0.w ;\n"
    "       c1.xyz  = (c1.xyz  * c0.w );\n"
    "       outColor.xyz  = ((c0.xyz  * (1.0 - c1.w )) + c1.xyz );\n"
    "       outColor = mix( original, outColor, vec4( c1.w ));\n"
    "       outColor.xyz  += colorAdd;\n"
    "       gl_FragColor =  outColor;\n"
    "   }\n"
    "}\n",

    "[ps-blend.ps] = blend.ps\n"
    "[ps-blend.ps][float][invertSample] = min 0 max 1 default 0 \n"
    "[ps-blend.ps][float][disableSample1] = min 0 max 1 default 0 \n"
    "[ps-blend.ps][rgb][colorAdd] = min 0 0 0 max 255 255 255 default 255 0 0 \n"
    "[ps-blend.ps][rgba][junctionRemove] = min 0 0 0 0 max 255 255 255 255 default 0.2 0.2 0.2 0.0  \n",
    // blend *********************

    // font color *********************
    "font.ps",

    "precision mediump float;\n"
    "uniform sampler2D sample0;\n"
    "uniform vec3 colorFont;\n"
    "\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec4 color;\n"
    "\n"
    "   color = texture2D(sample0, uv);\n"
    "   vec3 c2 = vec3(1.0 - colorFont.r,1.0 - colorFont.g,1.0 - colorFont.b);\n"
    "   color.rgb -= c2;\n"
    "   return color;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 xlat_retVal;\n"
    "   xlat_retVal = xlat_main(vTexCoord);\n"
    "   gl_FragColor = vec4(xlat_retVal);\n"
    "}\n",

    "[ps-font.ps] = font.ps\n"
    "[ps-font.ps][rgb][colorFont]             = min 0 0 0   max 1.0 1.0 1.0 default 1.0 1.0 1.0   \n",
    // font color *********************

    // Color Keying *********************
    "color keying.ps",

    "precision mediump float;\n"
    "\n"
    "uniform vec4 colorDst;\n"
    "uniform vec4 colorSrc;\n"
    "uniform float granThen;\n"
    "uniform sampler2D sample0;\n"
    "uniform float tolerance;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv, vec4 color)\n"
    "{\n"
    "\n"
    "   if ((granThen > 0.500000))\n"
    "   {\n"
    "       if (all(lessThan(abs((color.xyz - colorSrc.xyz)), vec3(tolerance))))\n"
    "       {\n"
    "           color.xyzw = colorDst;\n"
    "       }\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       if (all(greaterThan(abs((color.xyz - colorSrc.xyz)), vec3(tolerance))))\n"
    "       {\n"
    "           color.xyzw = colorDst;\n"
    "       }\n"
    "   }\n"
    "   return color;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   if ((color.w == 0.0))\n"
    "       discard;\n"
    "   else\n"
    "       gl_FragColor = xlat_main(vTexCoord, color);\n"
    "}\n",

    "[ps-color-keying.ps] = color keying.ps\n"
    "[ps-color-keying.ps][float][granThen]             = min 0.0              max 1.0              default 1.0             #boolean\n"
    "[ps-color-keying.ps][float][tolerance]            = min 0.0              max 1.0              default 0.3             #float\n"
    "[ps-color-keying.ps][rgba][colorDst]              = min 0.1 0.2 0.3 0.0  max 1.0 1.0 1.0 1.0  default 1.0 0.2 1.0 1.0 #cor RGBA definida como float\n"
    "[ps-color-keying.ps][rgba][colorSrc]              = min 10 20 30  255    max 125 128 250 255  default 125 128 50 255  #cor RGBA\n",
    // Color Keying *********************

	// tile map *********************
	"tiled map.ps",

	"precision mediump float;\n"
	"\n"
	"uniform float enableColorKeying;\n"
	"uniform float granThen;\n"
	"uniform float alpha;\n"
	"uniform float tolerance;\n"
	"uniform vec3 colorSrc;\n"
	"uniform sampler2D sample0;\n"
	"varying vec2 vTexCoord;\n"
	"\n"
	"\n"
	"void main()\n"
	"{\n"
	"  vec4 color = texture2D(sample0, vTexCoord);\n"
	"  color.a  -= alpha;\n"
	"  if (color.a <= 0.0)\n"
	"  {\n"
	"     discard;\n"
	"  }\n"
	"  else if (enableColorKeying > 0.5)\n"
	"  {\n"
	"    if (granThen > 0.5)\n"
	"    {\n"
	"        if (all(lessThan(abs((color.xyz - colorSrc.xyz)), vec3(tolerance))))\n"
	"        {\n"
	"            discard;\n"
	"        }\n"
	"        else\n"
	"        {\n"
	"          gl_FragColor = color;\n"
	"        }\n"
	"    }\n"
	"    else\n"
	"    {\n"
	"      if (all(greaterThan(abs((color.xyz - colorSrc.xyz)), vec3(tolerance))))\n"
	"      {\n"
	"         discard;\n"
	"      }\n"
	"      else\n"
	"      {\n"
	"        gl_FragColor = color;\n"
	"      }\n"
	"    }\n"
	"  }\n"
	"  else\n"
	"  {\n"
	"    gl_FragColor = color;\n"
	"  }\n"
	"}\n",

	"[ps-tiled-map.ps] = tiled map.ps\n"
	"[ps-tiled-map.ps][float][alpha]                = min 0.0        max 1.0          default 0.0\n"
	"[ps-tiled-map.ps][float][enableColorKeying]    = min 0.0        max 1.0          default 0.0\n"
	"[ps-tiled-map.ps][float][granThen]             = min 0.0        max 1.0          default 1.0\n"
	"[ps-tiled-map.ps][float][tolerance]            = min 0.0        max 1.0          default 0.3\n"
	"[ps-tiled-map.ps][rgb][colorSrc]               = min 0 0 0      max 255 255 255  default 255 0 255\n",

    // transparent *********************
    "transparent.ps",

    "precision mediump float;\n"
    "uniform float alpha;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "void main() \n"
    "{\n"
    "    vec4 color;\n"
    "    color = texture2D( sample0, vTexCoord);\n"
    "    color.a  -= alpha;\n"
    "    gl_FragColor = color;\n"
    "}\n"
    "\n",

    "[ps-transparent.ps] = transparent.ps\n"
    "[ps-transparent.ps][float][alpha]                = min 0.0              max 1.0              default 0.7\n",
    // transparent *********************

    // saturate *********************
    "saturate.ps",

    "precision mediump float;\n\n"
    "uniform vec3 color;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "vec4 xlat_main( in vec2 uv ) \n"
    "{\n"
    "    vec4 c1;\n"
    "    c1 = texture2D( sample0, uv.xy );\n"
    "    c1.xyz  *= color.xyz ;\n"
    "    return c1;\n"
    "}\n"

    "void main() \n"
    "{\n"
    "    gl_FragColor = xlat_main( vTexCoord);\n"
    "}\n",

    "[ps-saturate.ps] = saturate.ps\n"
    "[ps-saturate.ps][rgb][color]                = min 0.0 0.0 0.0           max 1.0 1.0 1.0           default 1.0 1.0 "
    "1.0\n",
    // saturate *********************

    // out of bounds **********************
    "out of bounds.ps",

    "precision mediump float;\n\n"
    "uniform sampler2D sample0;\n"
    "uniform vec3 color;\n"
    "varying vec2 vTexCoord;\n"
    "void main()\n"
    "{\n"
    "   vec4 colorRet = texture2D( sample0, vTexCoord.xy );\n"
    "   if(vTexCoord.x < 0.0 || vTexCoord.x > 1.0 || vTexCoord.y < 0.0 || vTexCoord.y > 1.0)\n"
    "      colorRet.rgb *= color.rgb;\n"
    "   gl_FragColor = colorRet;\n"
    "}\n",

    "[ps-out-of-bounds.ps] = out of bounds.ps\n"
    "[ps-out-of-bounds.ps][rgb][color]           = min 0 0 0     max 1.0 1.0 1.0     default 1.0 0.0 0.0 \n",
    // out of bounds **********************

    // color it **********************
    "color it.ps",

    "precision mediump float;\n\n"
    "uniform sampler2D sample0;\n"
    "uniform vec3 color;\n"
    "uniform float enable;\n"
    "varying vec2 vTexCoord;\n"
    "void main()\n"
    "{\n"
    "   vec4 c = texture2D( sample0, vTexCoord.xy );\n"
    "   if(enable > 0.5)\n"
    "      gl_FragColor = vec4(color.r,color.g,color.b,c.a);\n"
    "   else\n"
    "      gl_FragColor = c;\n"
    "}\n",

    "[ps-color-it.ps] = color it.ps\n"
    "[ps-color-it.ps][float][enable]        = min 0.0   max 1.0   default 1.0 \n"
    "[ps-color-it.ps][rgb][color]           = min 0.0 0.0 0.0     max 1.0 1.0 1.0     default 1.0 0.0 0.0 \n",


    // tint **********************
    "tint.ps",

    "precision mediump float;\n\n"
    "uniform sampler2D sample0;\n"
    "uniform vec3 color;\n"
    "varying vec2 vTexCoord;\n"
    "void main()\n"
    "{\n"
    "   vec4 tex = texture2D( sample0, vTexCoord.xy );\n"
    "   gl_FragColor = vec4(max(tex.r,color.r),max(tex.g,color.g),max(tex.b,color.b),tex.a);\n"
    "}\n",

    "[ps-tint.ps] = color it.ps\n"
    "[ps-tint.ps][rgb][color]           = min 0.0 0.0 0.0     max 1.0 1.0 1.0     default 1.0 0.0 0.0 \n",

    // color it **********************

    // Night Vision **********************
    "night vision.ps",

    "precision mediump float;\n"
    "uniform float fInverseViewportHeight;\n"
    "uniform float fInverseViewportWidth;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 col;\n"
    "   vec4 color0;\n"
    "\n"
    "   col = texture2D(sample0, vTexCoord);\n"
    "\n"
    "   color0 = col;\n"
    "   col += (0.0625000 * texture2D(sample0, (vTexCoord + vec2((-1.00000 * fInverseViewportWidth), (-1.00000 * "
    "fInverseViewportHeight)))));\n"
    "   col += (0.0625000 * texture2D(sample0, (vTexCoord + vec2((-1.00000 * fInverseViewportWidth), (1.00000 * "
    "fInverseViewportHeight)))));\n"
    "   col += (0.0625000 * texture2D(sample0, (vTexCoord + vec2((1.00000 * fInverseViewportWidth), (-1.00000 * "
    "fInverseViewportHeight)))));\n"
    "   col += (0.0625000 * texture2D(sample0, (vTexCoord + vec2((1.00000 * fInverseViewportWidth), (1.00000 * "
    "fInverseViewportHeight)))));\n"
    "   col += (0.125000 * texture2D(sample0, (vTexCoord + vec2((-1.00000 * fInverseViewportWidth), (0.000000 * "
    "fInverseViewportHeight)))));\n"
    "   col += (0.125000 * texture2D(sample0, (vTexCoord + vec2((1.00000 * fInverseViewportWidth), (0.000000 * "
    "fInverseViewportHeight)))));\n"
    "   col += (0.125000 * texture2D(sample0, (vTexCoord + vec2((0.000000 * fInverseViewportWidth), (-1.00000 * "
    "fInverseViewportHeight)))));\n"
    "   col += (0.125000 * texture2D(sample0, (vTexCoord + vec2((0.000000 * fInverseViewportWidth), (1.00000 * "
    "fInverseViewportHeight)))));\n"
    "   col += (0.250000 * texture2D(sample0, (vTexCoord + vec2((0.000000 * fInverseViewportWidth), (0.000000 * "
    "fInverseViewportHeight)))));\n"
    "   col = vec4((((0.299000 * col.x) + (0.587000 * col.y)) + (0.184000 * col.z)));\n"
    "   col = vec4(col.xxx, col.w);\n"
    "   col.y *= 3.00000;\n"
    "   col = ((col * color0) * 0.500000);\n"
    "   gl_FragColor = col;\n"
    "}\n",

    "[ps-night-vision.ps] = night vision.ps\n"
    "[ps-night-vision.ps][float][fInverseViewportWidth]   = min 0.00001    max 1.0      default 1.0\n"
    "[ps-night-vision.ps][float][fInverseViewportHeight]  = min 0.00001    max 1.0      default 1.0\n",
    // Night Vision **********************

    // Night Vision blur **********************
    "night vision blur.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float brightness;\n"
    "uniform float contrast;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec4 pixelColor)\n"
    "{\n"
    "   vec4 color0;\n"
    "   color0 = pixelColor;\n"
    "   pixelColor = vec4((((0.299000 * pixelColor.x) + (0.587000 * pixelColor.y)) + (0.184000 * pixelColor.z)));\n"
    "   pixelColor.xyz /= pixelColor.w;\n"
    "   pixelColor.xyz = (((pixelColor.xyz - 0.500000) * max(contrast, 0.000000)) + 0.500000);\n"
    "   pixelColor.y += brightness;\n"
    "   pixelColor.xyz *= pixelColor.w;\n"
    "   return ((pixelColor * color0) * 0.250000);\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   if(color.a == 0.0)\n"
    "      discard;\n"
    "   else\n"
    "      gl_FragColor = xlat_main(color);\n"
    "}\n",

    "[ps-night-vision-blur.ps] = night vision blur.ps\n"
    "[ps-night-vision-blur.ps][float][brightness]   = min 0.00001    max 100.0     default 10\n"
    "[ps-night-vision-blur.ps][float][contrast]     = min 0.00001    max 10.0      default 6.8\n",
    // Night Vision blur **********************

    // Multi textura **********************
    "multi textura.ps",

    "precision mediump float;\n"
    "\n"
    "varying vec2 vTexCoord;\n"
    "uniform float gamma;\n"
    "uniform sampler2D sample0;\n"
    "uniform sampler2D sample1;\n"
    "\n"
    "vec4 xlat_lib_saturate( vec4 x) \n"
    "{\n"
    "  return clamp( x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "void main() \n"
    "{\n"
    "   vec4 color1;\n"
    "   vec4 color2;\n"
    "   vec4 blendColor;\n"
    "   color1 = texture2D( sample0, vTexCoord.xy );\n"
    "   color2 = texture2D( sample1, vTexCoord.xy );\n"
    "   blendColor = ((color1 * color2) * gamma);\n"
    "   blendColor = xlat_lib_saturate( blendColor );\n"
    "   gl_FragColor = blendColor;\n"
    "}\n",

    "[ps-multi-textura.ps] = multi textura.ps\n"
    "[ps-multi-textura.ps][float][gamma]    = min 0.0    max 100.0     default 2.0\n",
    // Multi Textura **********************

    // Wave **********************
    "wave.ps",

    "precision mediump float;\n"
    "uniform sampler2D sample0;\n"
    "uniform float effectTime;\n"
    "uniform float sizeWave;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "float dist(in float a, in float b, in float c, in float d)\n"
    "{\n"
    "   return sqrt((((a - c) * (a - c)) + ((b - d) * (b - d))));\n"
    "}\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec4 Color;\n"
    "   float f;\n"
    "\n"
    "   Color = vec4(0.000000);\n"
    "   f = ((sin((dist((uv.x + effectTime), uv.y, 0.128000, 0.128000) * sizeWave)) + sin((dist(uv.x, uv.y, 0.640000, "
    "0.640000) * sizeWave))) + sin((dist(uv.x, (uv.y + (effectTime / 7.00000)), 0.192000, 0.640000) * sizeWave)));\n"
    "   uv.xy = (uv.xy + (f / sizeWave));\n"
    "   Color = texture2D(sample0, uv.xy);\n"
    "   return Color;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n",

    "[ps-wave.ps] = wave.ps\n"
    "[ps-wave.ps][float][effectTime]   = min 0.0    max 10.0      default 0.0\n"
    "[ps-wave.ps][float][sizeWave]     = min -50.0    max 100.0     default 10\n",
    // Wave **********************

    // Bands **********************
    "bands.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float bandDensity;\n"
    "uniform float bandIntensity;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "vec4 xlat_main(in vec4 color)\n"
    "{\n"
    "   color.xyz += (tan((vTexCoord.x * bandDensity)) * bandIntensity);\n"
    "   return color;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   gl_FragColor = xlat_main(color);\n"
    "}\n",

    "[ps-bands.ps] = bands.ps\n"
    "[ps-bands.ps][float][bandDensity]   = min 0.0   max 150.0   default 65.0\n"
    "[ps-bands.ps][float][bandIntensity] = min 0.001 max 0.56    default 0.56\n",
    // Bands **********************

    // Bloom **********************
    "bloom.ps",

    "precision mediump float;\n"
    "uniform float BaseIntensity;\n"
    "uniform float BaseSaturation;\n"
    "uniform float BloomIntensity;\n"
    "uniform float BloomSaturation;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "float xlat_lib_saturate(float x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec2 xlat_lib_saturate(vec2 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec3 xlat_lib_saturate(vec3 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec4 xlat_lib_saturate(vec4 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "mat2 xlat_lib_saturate(mat2 m)\n"
    "{\n"
    "   return mat2(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "mat3 xlat_lib_saturate(mat3 m)\n"
    "{\n"
    "   return mat3(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "mat4 xlat_lib_saturate(mat4 m)\n"
    "{\n"
    "   return mat4(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0), clamp(m[3], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "\n"
    "vec3 AdjustSaturation(in vec3 color, in float saturation)\n"
    "{\n"
    "   float grey;\n"
    "   grey = dot(color, vec3(0.3, 0.59, 0.11));\n"
    "   return vec3(mix(grey, float(color.xyz), saturation));\n"
    "}\n"
    "\n"
    "vec4 xlat_main(in vec4 color)\n"
    "{\n"
    "   float BloomThreshold = 0.250000;\n"
    "   vec3 base;\n"
    "   vec3 bloom;\n"
    "\n"
    "   base = (color.xyz / color.w);\n"
    "   bloom = xlat_lib_saturate(((base - BloomThreshold) / (1.00000 - BloomThreshold)));\n"
    "   bloom = (AdjustSaturation(bloom, BloomSaturation) * BloomIntensity);\n"
    "   base = (AdjustSaturation(base, BaseSaturation) * BaseIntensity);\n"
    "   base *= (1.00000 - xlat_lib_saturate(bloom));\n"
    "   return vec4(((base + bloom) * color.w), color.w);\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   if(color.a == 0.0)\n"
    "      discard;\n"
    "   else\n"
    "      gl_FragColor = xlat_main(color);\n"
    "}\n"
    "\n",

    "[ps-bloom.ps] = bloom.ps\n"
    "[ps-bloom.ps][float][BloomIntensity]   = min 0.0   max 2.0   default 1.0\n"
    "[ps-bloom.ps][float][BaseIntensity]    = min 0.0   max 2.0   default 0.5\n"
    "[ps-bloom.ps][float][BloomSaturation]  = min 0.0   max 2.0   default 1.0\n"
    "[ps-bloom.ps][float][BaseSaturation]   = min 0.0   max 2.0   default 0.5\n",
    // Bloom **********************

    // Bright Extract **********************
    "bright extract.ps",

    "precision mediump float;\n"
    "uniform sampler2D sample0;\n"
    "uniform float threshold;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "float xlat_lib_saturate(float x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec2 xlat_lib_saturate(vec2 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec3 xlat_lib_saturate(vec3 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec4 xlat_lib_saturate(vec4 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "mat2 xlat_lib_saturate(mat2 m)\n"
    "{\n"
    "   return mat2(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "mat3 xlat_lib_saturate(mat3 m)\n"
    "{\n"
    "   return mat3(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "mat4 xlat_lib_saturate(mat4 m)\n"
    "{\n"
    "   return mat4(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0), clamp(m[3], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec4 originalColor;\n"
    "   vec3 rgb;\n"
    "\n"
    "   originalColor = texture2D(sample0, uv);\n"
    "   rgb = (originalColor.xyz / originalColor.w);\n"
    "   rgb = xlat_lib_saturate(((rgb - threshold) / (1.00000 - threshold)));\n"
    "   return vec4((rgb * originalColor.w), originalColor.w);\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n"
    "\n",

    "[ps-bright-extract.ps] = bright extract.ps\n"
    "[ps-bright-extract.ps][float][threshold]   = min 0.0   max 1.0   default 0.5\n",
    // Bright Extract **********************

    // Color Tone **********************
    "color tone.ps",

    "precision mediump float;\n"
    "uniform vec4 darkColor;\n"
    "uniform float desaturation;\n"
    "uniform vec4 lightColor;\n"
    "uniform sampler2D sample0;\n"
    "uniform float toned;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv,in vec4 color)\n"
    "{\n"
    "   vec3 scnColor;\n"
    "   float gray;\n"
    "   vec3 muted;\n"
    "   vec3 middle;\n"
    "\n"
    "   color = texture2D(sample0, uv);\n"
    "   scnColor = (vec3(lightColor) * (color.xyz / color.w));\n"
    "   gray = dot(vec3(0.300000, 0.590000, 0.110000), scnColor);\n"
    "   muted = mix(scnColor, vec3(vec3(gray)), vec3(desaturation));\n"
    "   middle = vec3(mix(darkColor, lightColor, vec4(gray)));\n"
    "   scnColor = mix(muted, middle, vec3(toned));\n"
    "   return vec4((scnColor * color.w), color.w);\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color = texture2D(sample0, vTexCoord);\n"
    "   if (color.a == 0.0)\n"
    "       discard;\n"
    "   else"
    "      gl_FragColor = xlat_main(vTexCoord,color);\n"
    "}\n"
    "\n",

    "[ps-color-tone.ps] = color tone.ps\n"
    "[ps-color-tone.ps][float][desaturation] = min 0.0      max 1.0              default 0.5\n"
    "[ps-color-tone.ps][float][toned]        = min 0.0      max 1.0              default 0.5\n"
    "[ps-color-tone.ps][rgba][lightColor]    = min 0 0 0 0  max 255 255 255 255  default 255 255 255 255\n"
    "[ps-color-tone.ps][rgba][darkColor]     = min 0 0 0 0  max 255 255 255 255  default 255 255 0 0.7\n",
    // Color Tone **********************

    // Brightness **********************
    "brightness.ps",

    "precision mediump float;\n"
    "uniform float brightness;\n"
    "uniform float contrast;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv,in vec4 pixelColor)\n"
    "{\n"
    "   pixelColor.xyz /= pixelColor.w;\n"
    "   pixelColor.xyz = (((pixelColor.xyz - 0.500000) * max(contrast, 0.000000)) + 0.500000);\n"
    "   pixelColor.xyz += brightness;\n"
    "   pixelColor.xyz *= pixelColor.w;\n"
    "   return pixelColor;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color = texture2D(sample0, vTexCoord);\n"
    "   if (color.a == 0.0)\n"
    "       discard;\n"
    "   else"
    "       gl_FragColor = xlat_main(vTexCoord,color);\n"
    "}\n",

    "[ps-brightness.ps] = brightness.ps\n"
    "[ps-brightness.ps][float][brightness] = min 0.0      max 1.0              default 0.5\n"
    "[ps-brightness.ps][float][contrast]   = min 0.0      max 2.0              default 1.5\n",
    // Brightness **********************

    // Blur Directional **********************
    "blur directional.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float angle;\n"
    "uniform float blurAmount;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv,vec4 color)\n"
    "{\n"
    "   vec4 c;\n"
    "   float rad;\n"
    "   float xOffset;\n"
    "   float yOffset;\n"
    "   int i = 0;\n"
    "   c = vec4(0.0);\n"
    "   rad = (angle * 0.0174533);\n"
    "   xOffset = cos(rad);\n"
    "   yOffset = sin(rad);\n"
    "   for (; (i < 16); (++i))\n"
    "   {\n"
    "       uv.x = (uv.x - (blurAmount * xOffset));\n"
    "       uv.y = (uv.y - (blurAmount * yOffset));\n"
    "       c += texture2D(sample0, uv);\n"
    "   }\n"
    "   c /= 16.0000;\n"
    "   return c;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color = texture2D(sample0, vTexCoord);\n"
    "   gl_FragColor = xlat_main(vTexCoord,color);\n"
    "}\n",

    "[ps-blur-directional.ps] = blur directional.ps\n"
    "[ps-blur-directional.ps][float][angle]      = min 0.0      max 360.0      default 0.0\n"
    "[ps-blur-directional.ps][float][blurAmount] = min 0.000    max 0.01       default 0.000\n",
    // Blur Direcional **********************

    // Embossed **********************
    "embossed.ps",

    "precision mediump float;\n"
    " \n"
    "uniform float amount;\n"
    "uniform sampler2D sample0;\n"
    "uniform float width;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec4 outC = vec4(0.500000, 0.500000, 0.500000, 1.00000);\n"
    "   outC -= (texture2D(sample0, (uv - width)) * amount);\n"
    "   outC += (texture2D(sample0, (uv + width)) * amount);\n"
    "   outC.xyz = vec3((((outC.x + outC.y) + outC.z) / 3.00000));\n"
    "   return outC;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   if (color.a == 0.0)\n"
    "       discard;\n"
    "   else\n"
    "       gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n",

    "[ps-embossed.ps] = embossed.ps\n"
    "[ps-embossed.ps][float][amount]      = min 0.0      max 1.0      default 0.5\n"
    "[ps-embossed.ps][float][width]       = min 0.0      max 0.1      default 0.0022999998\n",
    // Embossed **********************

    // Frosty out line **********************
    "frosty out line.ps",

    "precision mediump float;\n"
    "uniform float height;\n"
    "uniform sampler2D sample0;\n"
    "uniform float width;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 middle)\n"
    "{\n"
    "   vec2 topLeft;\n"
    "   vec2 top;\n"
    "   vec2 topRight;\n"
    "   vec2 left;\n"
    "   vec2 right;\n"
    "   vec2 bottomLeft;\n"
    "   vec2 bottom;\n"
    "   vec2 bottomRight;\n"
    "   vec4 m;\n"
    "   vec4 tl;\n"
    "   vec4 l;\n"
    "   vec4 bl;\n"
    "   vec4 t;\n"
    "   vec4 b;\n"
    "   vec4 tr;\n"
    "   vec4 r;\n"
    "   vec4 br;\n"
    "   vec4 color;\n"
    "   vec4 color2;\n"
    "   float avg;\n"
    "\n"
    "   topLeft.x = (middle.x - (1.00000 / width));\n"
    "   topLeft.y = (middle.y - (1.00000 / height));\n"
    "   top.x = middle.x;\n"
    "   top.y = (middle.y - (1.00000 / height));\n"
    "   topRight.x = (middle.x + (1.00000 / width));\n"
    "   topRight.y = (middle.y - (1.00000 / height));\n"
    "   left.x = (middle.x - (1.00000 / width));\n"
    "   left.y = middle.y;\n"
    "   right.x = (middle.x + (1.00000 / width));\n"
    "   right.y = middle.y;\n"
    "   bottomLeft.x = (middle.x - (1.00000 / width));\n"
    "   bottomLeft.y = (middle.y + (1.00000 / height));\n"
    "   bottom.x = middle.x;\n"
    "   bottom.y = (middle.y + (1.00000 / height));\n"
    "   bottomRight.x = (middle.x + (1.00000 / width));\n"
    "   bottomRight.y = (middle.y + (1.00000 / height));\n"
    "   m = texture2D(sample0, middle);\n"
    "   tl = texture2D(sample0, topLeft);\n"
    "   l = texture2D(sample0, left);\n"
    "   bl = texture2D(sample0, bottomLeft);\n"
    "   t = texture2D(sample0, top);\n"
    "   b = texture2D(sample0, bottom);\n"
    "   tr = texture2D(sample0, topRight);\n"
    "   r = texture2D(sample0, right);\n"
    "   br = texture2D(sample0, bottomRight);\n"
    "   color = (((((-tl) - t) - tr) + (((-l) + (8.00000 * m)) - r)) + (((-bl) - b) - br));\n"
    "   color2 = texture2D(sample0, middle);\n"
    "   avg = ((color.x + color.y) + color.z);\n"
    "   avg /= 3.00000;\n"
    "   color.xyz = vec3(avg);\n"
    "   color.w = 1.00000;\n"
    "   return (color2 + color);\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   if(color.a == 0.0)\n"
    "      discard;\n"
    "   else\n"
    "      gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n"
    "\n",

    "[ps-frosty-out-line.ps] = frosty out line.ps\n"
    "[ps-frosty-out-line.ps][float][width]      = min 0.0      max 650.0      default 300.0\n"
    "[ps-frosty-out-line.ps][float][height]     = min 0.0      max 500.0      default 300.0\n",
    // Frosty Out Line **********************

    // Glass Tile **********************
    "glass tile.ps",

    "precision mediump float;\n"
    "uniform float bevelWidth;\n"
    "uniform vec4 groutColor;\n"
    "uniform float offset;\n"
    "uniform sampler2D sample0;\n"
    "uniform float tiles;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "void main()\n"
    "{\n"
    "   float a = texture2D(sample0, vTexCoord).a;\n"
    "   if(a == 0.0 && groutColor.a == 0.0)\n"
    "      discard;\n"
    "   else\n"
    "   {\n"
    "       vec2 newUV1;\n"
    "       vec4 c1;\n"
    "       newUV1.xy = (vTexCoord.xy + (tan((((tiles * 2.50000) * vTexCoord.xy) + offset)) * (bevelWidth / 100.000)));\n"
    "       c1 = texture2D(sample0, newUV1);\n"
    "       if(c1.a == 0.0  && groutColor.a == 0.0)\n"
    "          discard;\n"
    "       else\n"
    "       {\n"
    "          if (((((newUV1.x < 0.000000) || (newUV1.x > 1.00000)) || (newUV1.y < 0.000000)) || (newUV1.y > 1.00000)))\n"
    "          {\n"
    "              c1 = groutColor;\n"
    "          }\n"
    "          if(c1.a == 0.0  && groutColor.a == 0.0)\n"
    "             discard;\n"
    "          else\n"
    "          {\n"
    "             gl_FragColor = c1;\n"
    "          }\n"
    "       }\n"
    "   }\n"
    "}\n",

    "[ps-glass-tile.ps] = glass tile.ps\n"
    "[ps-glass-tile.ps][float][tiles]        = min 0.0           max 20.0                 default 5.0\n"
    "[ps-glass-tile.ps][float][bevelWidth]   = min 1.0           max 10.0                 default 10.0\n"
    "[ps-glass-tile.ps][float][offset]       = min 0.0           max 3.0                  default 3.0\n"
    "[ps-glass-tile.ps][rgba][groutColor]    = min 0 0 0 0       max 255 255 255 255      default 0 0 0 0 \n",
    // Glass Tile **********************

    // Poisson **********************
    "poisson.ps",

    "precision mediump float;\n"
    "uniform vec2 inputSize;\n"
    "uniform float poisson;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec4 cOut;\n"
    "   vec2 coord;\n"
    "\n"
    "   cOut = texture2D(sample0, uv);\n"
    "   coord = (uv.xy + ((vec2(-0.326212, -0.405810) / inputSize) * poisson));\n" //"      float2(-0.326212f,
                                                                                   //-0.40581f),\n"
    "   cOut += texture2D(sample0, coord);\n"
    "   \n"
    "   coord = (uv.xy + ((vec2(-0.840144, -0.07358) / inputSize) * poisson));\n" //"       float2(-0.840144f,
                                                                                  //-0.07358f),\n"
    "   cOut += texture2D(sample0, coord);\n"
    "   \n"
    "   coord = (uv.xy + ((vec2(-0.695914, 0.457137) / inputSize) * poisson));\n" //"       float2(-0.695914f,
                                                                                  // 0.457137f),\n"
    "   cOut += texture2D(sample0, coord);\n"
    "   \n"
    "   coord = (uv.xy + ((vec2(-0.203345, 0.620716) / inputSize) * poisson));\n" //"       float2(-0.203345f,
                                                                                  // 0.620716f),\n"
    "   cOut += texture2D(sample0, coord);\n"
    "   \n"
    "   coord = (uv.xy + ((vec2(0.96234, -0.194983) / inputSize) * poisson));\n" //"        float2(0.96234f,
                                                                                 //-0.194983f),\n"
    "   cOut += texture2D(sample0, coord);\n"
    "   \n"
    "   coord = (uv.xy + ((vec2(0.473434, -0.480026) / inputSize) * poisson));\n" //"       float2(0.473434f,
                                                                                  //-0.480026f),\n"
    "   cOut += texture2D(sample0, coord);\n"
    "   \n"
    "   coord = (uv.xy + ((vec2(0.519456, 0.767022) / inputSize) * poisson));\n" //"        float2(0.519456f,
                                                                                 // 0.767022f),\n"
    "   cOut += texture2D(sample0, coord);\n"
    "   \n"
    "   coord = (uv.xy + ((vec2(0.185461, -0.893124) / inputSize) * poisson));\n" //"       float2(0.185461f,
                                                                                  //-0.893124f),\n"
    "   cOut += texture2D(sample0, coord);\n"
    "   \n"
    "   coord = (uv.xy + ((vec2(0.507431, 0.064425) / inputSize) * poisson));\n" //"        float2(0.507431f,
                                                                                 // 0.064425f),\n"
    "   cOut += texture2D(sample0, coord);\n"
    "   \n"
    "   coord = (uv.xy + ((vec2(0.89642, 0.412458) / inputSize) * poisson));\n" //"     float2(0.89642f, 0.412458f),\n"
    "   cOut += texture2D(sample0, coord);\n"
    "   \n"
    "   coord = (uv.xy + ((vec2(-0.32194, -0.932615) / inputSize) * poisson));\n" //"       float2(-0.32194f,
                                                                                  //-0.932615f),\n"
    "   cOut += texture2D(sample0, coord);\n"
    "   \n"
    "   coord = (uv.xy + ((vec2(-0.791559, -0.59771) / inputSize) * poisson));\n" //"       float2(-0.791559f,
                                                                                  //-0.59771f)\n"
    "   cOut += texture2D(sample0, coord);\n"
    "       \n"
    "   return (cOut / 13.0000);\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n"
    "\n",

    "[ps-poisson.ps] = poisson.ps\n"
    "[ps-poisson.ps][float][poisson]       = min 1.0           max 10.0                 default 3.0\n"
    "[ps-poisson.ps][vector2][inputSize]   = min 1.0 1.0       max 300.0 300.0        default 100.0 100.0\n",
    // Poisson **********************

    // Invert Color **********************
    "invert color.ps",

    "precision mediump float;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec4 color;\n"
    "   vec4 invertedColor;\n"
    "\n"
    "   color = texture2D(sample0, uv);\n"
    "   invertedColor = vec4((color.w - color.xyz), color.w);\n"
    "   return invertedColor;\n"
    "}\n"
    "void main()\n"
    "{\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n",

    "[ps-invert-color.ps] = invert color.ps\n",
    // Invert Color **********************

    // Magnifying glass **********************
    "magnifying glass.ps",

    "precision mediump float;\n"
    "uniform float aspectRatio;\n"
    "uniform vec2 center;\n"
    "uniform float magnification;\n"
    "uniform float radius;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec2 centerToPixel;\n"
    "   float dist;\n"
    "   vec2 samplePoint;\n"
    "\n"
    "   centerToPixel = (uv - center);\n"
    "   dist = length((centerToPixel / vec2(1.00000, aspectRatio)));\n"
    "   samplePoint = uv;\n"
    "   if ((dist < radius))\n"
    "   {\n"
    "       samplePoint = (center + (centerToPixel / magnification));\n"
    "   }\n"
    "   return texture2D(sample0, samplePoint);\n"
    "}\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   if (color.a == 0.0)\n"
    "       discard;\n"
    "   else\n"
    "       gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n",

    "[ps-magnifying-glass.ps] = magnifying glass.ps\n"
    "[ps-magnifying-glass.ps][vector2][center]       = min 0.0 0.0       max 1.0 1.0             default 0.5 0.5\n"
    "[ps-magnifying-glass.ps][float][radius]         = min 0.0           max 1.0                 default 0.25\n"
    "[ps-magnifying-glass.ps][float][magnification]  = min 0.0           max 5.0                 default 2.0\n"
    "[ps-magnifying-glass.ps][float][aspectRatio]    = min 0.5           max 2.0                 default 0.94\n",
    // Magnifying glass  **********************

    // Old Movie **********************
    "old movie.ps",

    "precision mediump float;\n"
    "uniform float frame;\n"
    "uniform float noiseAmount;\n"
    "uniform sampler2D sample0;\n"
    "uniform float scratchAmount;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv,in vec4 color)\n"
    "{\n"
    "   float ScratchAmountInv;\n"
    "   vec2 sc;\n"
    "   float scratch;\n"
    "   vec2 rCoord;\n"
    "   vec3 rand;\n"
    "   float gray;\n"
    "   vec2 dist;\n"
    "\n"
    "   ScratchAmountInv = (1.00000 / scratchAmount);\n"
    "   sc = (frame * vec2(0.00100000, 0.400000));\n"
    "   sc.x = fract((uv.x + sc.x));\n"
    "   scratch = sc.x;\n"
    "   scratch = ((2.00000 * scratch) * ScratchAmountInv);\n"
    "   scratch = (1.00000 - abs((1.00000 - scratch)));\n"
    "   scratch = max(0.000000, scratch);\n"
    "   color.xyz += vec3(scratch);\n"
    "   rCoord = (uv * 0.330000);\n"
    "   rand = vec3(texture2D(sample0, rCoord));\n"
    "   if ((noiseAmount > rand.x))\n"
    "   {\n"
    "       color.xyz = vec3((0.100000 + (rand.z * 0.400000)));\n"
    "   }\n"
    "   gray = dot(color, vec4(0.300000, 0.590000, 0.110000, 0.000000));\n"
    "   color = vec4((gray * vec3(0.900000, 0.800000, 0.600000)), 1.00000);\n"
    "   dist = (0.500000 - uv);\n"
    "   color.xyz *= ((0.400000 - dot(dist, dist)) * 2.80000);\n"
    "   return color;\n"
    "}\n"
    "\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   if(color.a == 0.0)\n"
    "      discard;\n"
    "   else\n"
    "      gl_FragColor = xlat_main(vTexCoord,color);\n"
    "}\n",

    "[ps-old-movie.ps] = old movie.ps\n"
    "[ps-old-movie.ps][float][scratchAmount]       = min 0.00001     max 0.1             default 0.044\n"
    "[ps-old-movie.ps][float][noiseAmount]         = min 0.00001     max 1.0             default 0.0001\n"
    "[ps-old-movie.ps][float][frame]               = min 0.0         max 2.0             default 1.0\n",
    // Old Movie **********************

    // Pinch mouse **********************
    "pinch mouse.ps",

    "precision mediump float;\n"
    "uniform float aspectRatio;\n"
    "uniform vec2 center;\n"
    "uniform float radius;\n"
    "uniform sampler2D sample0;\n"
    "uniform float strength;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "float xlat_lib_saturate(float x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec2 xlat_lib_saturate(vec2 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec3 xlat_lib_saturate(vec3 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec4 xlat_lib_saturate(vec4 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "mat2 xlat_lib_saturate(mat2 m)\n"
    "{\n"
    "   return mat2(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "mat3 xlat_lib_saturate(mat3 m)\n"
    "{\n"
    "   return mat3(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "mat4 xlat_lib_saturate(mat4 m)\n"
    "{\n"
    "   return mat4(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0), clamp(m[3], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec2 newCenter;\n"
    "   vec2 dir;\n"
    "   vec2 scaledDir;\n"
    "   float dist;\n"
    "   float range;\n"
    "   vec2 samplePoint;\n"
    "\n"
    "   newCenter.x = (1.00000 - (center.x / 794.000));\n"
    "   newCenter.y = (1.00000 - (center.y / 678.000));\n"
    "   dir = (newCenter - uv);\n"
    "   scaledDir = dir;\n"
    "   scaledDir.y /= aspectRatio;\n"
    "   dist = length(scaledDir);\n"
    "   range = xlat_lib_saturate((1.00000 - (dist / (abs(((-sin((radius * 8.00000))) * radius)) + 1.00000e-008))));\n"
    "   samplePoint = (uv + ((dir * range) * strength));\n"
    "   return texture2D(sample0, samplePoint);\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n",

    "[ps-pinch-mouse.ps] = pinch mouse.ps\n"
    "[ps-pinch-mouse.ps][vector2][center]         = min 0.0 0.0     max 794.0 678.0  default 0.5 0.5\n"
    "[ps-pinch-mouse.ps][float][radius]           = min 0.0         max 1            default 0.25\n"
    "[ps-pinch-mouse.ps][float][strength]         = min 0.0         max 2            default 1.0\n"
    "[ps-pinch-mouse.ps][float][aspectRatio]      = min 0.5         max 2            default 1.0\n",
    // Pinch mouse**********************

    // Pinch **********************
    "pinch.ps",

    "precision mediump float;\n"
    "uniform float aspectRatio;\n"
    "uniform vec2 center;\n"
    "uniform float radius;\n"
    "uniform sampler2D sample0;\n"
    "uniform float strength;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "float xlat_lib_saturate(float x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec2 xlat_lib_saturate(vec2 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec3 xlat_lib_saturate(vec3 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec4 xlat_lib_saturate(vec4 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "mat2 xlat_lib_saturate(mat2 m)\n"
    "{\n"
    "   return mat2(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "mat3 xlat_lib_saturate(mat3 m)\n"
    "{\n"
    "   return mat3(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "mat4 xlat_lib_saturate(mat4 m)\n"
    "{\n"
    "   return mat4(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0), clamp(m[3], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec2 dir;\n"
    "   vec2 scaledDir;\n"
    "   float dist;\n"
    "   float range;\n"
    "   vec2 samplePoint;\n"
    "\n"
    "   dir = (center - uv);\n"
    "   scaledDir = dir;\n"
    "   scaledDir.y /= aspectRatio;\n"
    "   dist = length(scaledDir);\n"
    "   range = xlat_lib_saturate((1.00000 - (dist / (abs(((-sin((radius * 8.00000))) * radius)) + 1.00000e-008))));\n"
    "   samplePoint = (uv + ((dir * range) * strength));\n"
    "   return texture2D(sample0, samplePoint);\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n",

    "[ps-pinch.ps] = pinch.ps\n"
    "[ps-pinch.ps][vector2][center]         = min 0.0 0.0     max 1.0 1.0      default 0.5 0.5\n"
    "[ps-pinch.ps][float][radius]           = min 0.0         max 1            default 0.25\n"
    "[ps-pinch.ps][float][strength]         = min 0.0         max 2            default 1.0\n"
    "[ps-pinch.ps][float][aspectRatio]      = min 0.5         max 2            default 1.0\n",
    // Pinch **********************

    // Ripple **********************
    "ripple.ps",

    "precision mediump float;\n"
    "uniform float amplitude;\n"
    "uniform float aspectRatio;\n"
    "uniform vec2 center;\n"
    "uniform float frequency;\n"
    "uniform float phase;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "void xlat_lib_sincos(float x, out float s, out float c)\n"
    "{\n"
    "   s = sin(x);\n"
    "   c = cos(x);\n"
    "}\n"
    "\n"
    "void xlat_lib_sincos(vec2 x, out vec2 s, out vec2 c)\n"
    "{\n"
    "   s = sin(x);\n"
    "   c = cos(x);\n"
    "}\n"
    "\n"
    "void xlat_lib_sincos(vec3 x, out vec3 s, out vec3 c)\n"
    "{\n"
    "   s = sin(x);\n"
    "   c = cos(x);\n"
    "}\n"
    "\n"
    "void xlat_lib_sincos(vec4 x, out vec4 s, out vec4 c)\n"
    "{\n"
    "   s = sin(x);\n"
    "   c = cos(x);\n"
    "}\n"
    "\n"
    "void xlat_lib_sincos(mat2 x, out mat2 s, out mat2 c)\n"
    "{\n"
    "   s = mat2(sin(x[0]), sin(x[1]));\n"
    "   c = mat2(cos(x[0]), cos(x[1]));\n"
    "}\n"
    "\n"
    "void xlat_lib_sincos(mat3 x, out mat3 s, out mat3 c)\n"
    "{\n"
    "   s = mat3(sin(x[0]), sin(x[1]), sin(x[2]));\n"
    "   c = mat3(cos(x[0]), cos(x[1]), cos(x[2]));\n"
    "}\n"
    "\n"
    "void xlat_lib_sincos(mat4 x, out mat4 s, out mat4 c)\n"
    "{\n"
    "   s = mat4(sin(x[0]), sin(x[1]), sin(x[2]), sin(x[3]));\n"
    "   c = mat4(cos(x[0]), cos(x[1]), cos(x[2]), cos(x[3]));\n"
    "}\n"
    "\n"
    "float xlat_lib_saturate(float x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec2 xlat_lib_saturate(vec2 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec3 xlat_lib_saturate(vec3 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec4 xlat_lib_saturate(vec4 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "mat2 xlat_lib_saturate(mat2 m)\n"
    "{\n"
    "   return mat2(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "mat3 xlat_lib_saturate(mat3 m)\n"
    "{\n"
    "   return mat3(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "mat4 xlat_lib_saturate(mat4 m)\n"
    "{\n"
    "   return mat4(clamp(m[0], 0.0, 1.0), clamp(m[1], 0.0, 1.0), clamp(m[2], 0.0, 1.0), clamp(m[3], 0.0, 1.0));\n"
    "}\n"
    "\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec2 dir;\n"
    "   float dist;\n"
    "   vec2 wave;\n"
    "   float falloff;\n"
    "   vec2 samplePoint;\n"
    "   vec4 color;\n"
    "   float lighting;\n"
    "\n"
    "   dir = (uv - center);\n"
    "   dir.y /= aspectRatio;\n"
    "   dist = length(dir);\n"
    "   dir /= dist;\n"
    "   dir.y *= aspectRatio;\n"
    "   xlat_lib_sincos(((frequency * dist) + phase), wave.x, wave.y);\n"
    "   falloff = xlat_lib_saturate((1.00000 - dist));\n"
    "   falloff *= falloff;\n"
    "   dist += ((amplitude * wave.x) * falloff);\n"
    "   samplePoint = (center + (dist * dir));\n"
    "   color = texture2D(sample0, samplePoint);\n"
    "   lighting = (1.00000 - ((amplitude * 0.200000) * (1.00000 - xlat_lib_saturate((wave.y * falloff)))));\n"
    "   color.xyz *= lighting;\n"
    "   return color;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n",

    "[ps-ripple.ps] = ripple.ps\n"
    "[ps-ripple.ps][vector2][center]         = min 0.0 0.0     max 1.0 1.0      default 0.5 0.5\n"
    "[ps-ripple.ps][float][amplitude]        = min 0.0         max 1.0          default 0.1\n"
    "[ps-ripple.ps][float][frequency]        = min 0.0         max 100.0        default 70.0\n"
    "[ps-ripple.ps][float][phase]            = min -20.0       max 20.0         default 0.0\n"
    "[ps-ripple.ps][float][aspectRatio]      = min 0.5         max 2.0          default 1.34\n",
    // Ripple **********************

    // Sharpen **********************
    "sharpen.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float amount;\n"
    "uniform vec2 inputSize;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec2 offset;\n"
    "   vec4 color;\n"
    "\n"
    "   offset = (1.00000 / inputSize);\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   color.xyz += vec3((texture2D(sample0, (vTexCoord - offset)) * amount));\n"
    "   color.xyz -= vec3((texture2D(sample0, (vTexCoord + offset)) * amount));\n"
    "   gl_FragColor = color;\n"
    "}\n",

    "[ps-sharpen.ps] = sharpen.ps\n"
    "[ps-sharpen.ps][vector2][inputSize]     = min 1.0 1.0     max 1000.0 1000.0      default 800.0 600.0\n"
    "[ps-sharpen.ps][float][amount]          = min 0.0         max 2.0                default 1.0 \n",
    // sharpen **********************

    // Sketch **********************
    "sketch.ps",

    "precision mediump float;\n"
    "\n"
    "uniform sampler2D Image;\n"
    "uniform float brushSize;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "const vec2 sample1 = vec2(0.000000, -1.00000);\n"
    "const vec2 sample2 = vec2(-1.00000, 0.000000);\n"
    "const vec2 sample3 = vec2(1.00000, 0.000000);\n"
    "const vec2 sample4 = vec2(0.000000, 1.00000);\n"
    "\n"
    "vec4 xlat_main(in vec2 texCoord)\n"
    "{\n"
    "   vec4 color;\n"
    "   vec4 laplace;\n"
    "   vec4 complement;\n"
    "   float gray;\n"
    "   float gray_1;\n"
    "\n"
    "   color = texture2D(Image, texCoord);\n"
    "   laplace = (-4.00000 * color);\n"
    "   \n"
    "   laplace += texture2D(Image, (texCoord + (brushSize * sample1)));\n"
    "   laplace.x = float(laplace.xyz);\n"
    "   laplace.y = float(laplace.xyz);\n"
    "   laplace.z = float(laplace.xyz);\n"
    "   \n"
    "   laplace += texture2D(Image, (texCoord + (brushSize * sample2)));\n"
    "   laplace.x = float(laplace.xyz);\n"
    "   laplace.y = float(laplace.xyz);\n"
    "   laplace.z = float(laplace.xyz);\n"
    "   \n"
    "   laplace += texture2D(Image, (texCoord + (brushSize * sample3)));\n"
    "   laplace.x = float(laplace.xyz);\n"
    "   laplace.y = float(laplace.xyz);\n"
    "   laplace.z = float(laplace.xyz);\n"
    "   \n"
    "   laplace += texture2D(Image, (texCoord + (brushSize * sample2)));\n"
    "   laplace.x = float(laplace.xyz);\n"
    "   laplace.y = float(laplace.xyz);\n"
    "   laplace.z = float(laplace.xyz);\n"
    "   \n"
    "   laplace = (1.00000 / laplace);\n"
    "   complement.xyz = (1.00000 - laplace.xyz);\n"
    "   complement.w = color.w;\n"
    "   if ((complement.x > 1.00000))\n"
    "   {\n"
    "       gray = (((complement.x * 0.300000) + (complement.y * 0.590000)) + (complement.z * 0.110000));\n"
    "       complement.x = gray;\n"
    "       complement.y = gray;\n"
    "       complement.z = gray;\n"
    "       return complement;\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       gray_1 = (((color.x * 0.300000) + (color.y * 0.590000)) + (color.z * 0.110000));\n"
    "       color.x = gray_1;\n"
    "       color.y = gray_1;\n"
    "       color.z = gray_1;\n"
    "       return color;\n"
    "   }\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n"
    "\n",

    "[ps-sketch.ps] = sketch.ps\n"
    "[ps-sketch.ps][float][brushSize]          = min 0.0006         max 1.0                default 0.003 \n",
    // Sketch **********************

    // Smooth Magnify **********************
    "smooth magnify.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float aspectRatio;\n"
    "uniform vec2 center;\n"
    "uniform float innerRadius;\n"
    "uniform float magnification;\n"
    "uniform float outerRadius;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec2 centerToPixel;\n"
    "   float dist;\n"
    "   float ratio;\n"
    "   vec2 samplePoint;\n"
    "\n"
    "   centerToPixel = (uv - center);\n"
    "   dist = length((centerToPixel / vec2(1.00000, aspectRatio)));\n"
    "   ratio = smoothstep(innerRadius, max(innerRadius, outerRadius), dist);\n"
    "   samplePoint = mix((center + (centerToPixel / magnification)), uv, vec2(ratio));\n"
    "   return texture2D(sample0, samplePoint);\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n",

    "[ps-smooth-magnify.ps] = smooth magnify.ps\n"
    "[ps-smooth-magnify.ps][vector2][center]          = min 0.0 0.0     max 1.0 1.0            default 0.5 0.5 \n"
    "[ps-smooth-magnify.ps][float][innerRadius]       = min 0.0         max 1.0                default 0.2 \n"
    "[ps-smooth-magnify.ps][float][outerRadius]       = min 0.0         max 1.0                default 0.4 \n"
    "[ps-smooth-magnify.ps][float][magnification]     = min 0.0         max 5.0                default 2.0 \n"
    "[ps-smooth-magnify.ps][float][aspectRatio]       = min 0.5         max 2.0                default 1.4 \n",
    // Smooth Magnify **********************

    // Spiral **********************
    "spiral.ps",

    "precision mediump float;\n"
    "uniform float aspectRatio;\n"
    "uniform vec2 center;\n"
    "uniform sampler2D sample0;\n"
    "uniform float spiralStrength;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "void xlat_lib_sincos(float x, out float s, out float c)\n"
    "{\n"
    "   s = sin(x);\n"
    "   c = cos(x);\n"
    "}\n"
    "\n"
    "void xlat_lib_sincos(vec2 x, out vec2 s, out vec2 c)\n"
    "{\n"
    "   s = sin(x);\n"
    "   c = cos(x);\n"
    "}\n"
    "\n"
    "void xlat_lib_sincos(vec3 x, out vec3 s, out vec3 c)\n"
    "{\n"
    "   s = sin(x);\n"
    "   c = cos(x);\n"
    "}\n"
    "\n"
    "void xlat_lib_sincos(vec4 x, out vec4 s, out vec4 c)\n"
    "{\n"
    "   s = sin(x);\n"
    "   c = cos(x);\n"
    "}\n"
    "\n"
    "void xlat_lib_sincos(mat2 x, out mat2 s, out mat2 c)\n"
    "{\n"
    "   s = mat2(sin(x[0]), sin(x[1]));\n"
    "   c = mat2(cos(x[0]), cos(x[1]));\n"
    "}\n"
    "\n"
    "void xlat_lib_sincos(mat3 x, out mat3 s, out mat3 c)\n"
    "{\n"
    "   s = mat3(sin(x[0]), sin(x[1]), sin(x[2]));\n"
    "   c = mat3(cos(x[0]), cos(x[1]), cos(x[2]));\n"
    "}\n"
    "\n"
    "void xlat_lib_sincos(mat4 x, out mat4 s, out mat4 c)\n"
    "{\n"
    "   s = mat4(sin(x[0]), sin(x[1]), sin(x[2]), sin(x[3]));\n"
    "   c = mat4(cos(x[0]), cos(x[1]), cos(x[2]), cos(x[3]));\n"
    "}\n"
    "\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec2 dir;\n"
    "   float dist;\n"
    "   float angle;\n"
    "   float newAngle;\n"
    "   vec2 newDir;\n"
    "   vec2 samplePoint;\n"
    "   bool isValid;\n"
    "\n"
    "   dir = (uv - center);\n"
    "   dir.y /= aspectRatio;\n"
    "   dist = length(dir);\n"
    "   angle = atan(dir.y, dir.x);\n"
    "   newAngle = (angle + (spiralStrength * dist));\n"
    "   xlat_lib_sincos(newAngle, newDir.y, newDir.x);\n"
    "   newDir.y *= aspectRatio;\n"
    "   samplePoint = (center + (newDir * dist));\n"
    "   if ((all(greaterThanEqual(samplePoint, vec2(0.000000))) && all(lessThanEqual(samplePoint, vec2(1.00000)))))\n"
    "   {\n"
    "       isValid = true;\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       isValid = false;\n"
    "   }\n"
    "   return (isValid) ? (texture2D(sample0, samplePoint)) : (vec4(0.000000, 0.000000, 0.000000, 0.000000));\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n",

    "[ps-spiral.ps] = spiral.ps\n"

    "[ps-spiral.ps][vector2][center]          = min 0.0 0.0     max 1.0 1.0            default 0.5 0.5 \n"
    "[ps-spiral.ps][float][spiralStrength]    = min 0.0         max 20.0               default 10.0 \n"
    "[ps-spiral.ps][float][aspectRatio]       = min 0.5         max 2.0                default 1.4 \n",
    // Spiral **********************

    // Tone Mapping **********************
    "tone mapping.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float blueShift;\n"
    "uniform float defog;\n"
    "uniform float exposure;\n"
    "uniform vec4 fogColor;\n"
    "uniform float gamma;\n"
    "uniform sampler2D sample0;\n"
    "uniform float vignetteAmount;\n"
    "uniform vec2 vignetteCenter;\n"
    "uniform float vignetteRadius;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv, in vec4 c)\n"
    "{\n"
    "   vec2 tc;\n"
    "   float v;\n"
    "   vec3 d;\n"
    "\n"
    "   c.xyz = vec3(max(0.000000, float((c.xyz - (defog * fogColor.xyz)))));\n"
    "   c.xyz *= pow(2.00000, exposure);\n"
    "   c.xyz = pow(c.xyz, vec3(gamma));\n"
    "   tc = (uv - vignetteCenter);\n"
    "   v = (length(tc) / vignetteRadius);\n"
    "   c.xyz += (pow(v, 4.00000) * vignetteAmount);\n"
    "   d = (c.xyz * vec3(1.05000, 0.970000, 1.27000));\n"
    "   c.xyz = mix(c.xyz, d, vec3(blueShift));\n"
    "   return c;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   gl_FragColor = xlat_main(vTexCoord,color);\n"
    "}\n",

    "[ps-tone-mapping.ps] = tone mapping.ps\n"
    "[ps-tone-mapping.ps][vector2][vignetteCenter]  = min 0.0 0.0     max 1.0 1.0            default 0.5 0.5 \n"
    "[ps-tone-mapping.ps][float][defog]             = min 0.0         max 1.0                default 0.4 \n"
    "[ps-tone-mapping.ps][float][exposure]          = min -1.0        max 1.0                default -0.2 \n"
    "[ps-tone-mapping.ps][float][gamma]             = min 0.5         max 2.0                default 0.63 \n"
    "[ps-tone-mapping.ps][float][vignetteRadius]    = min 0.0         max 1.0                default 0.5 \n"
    "[ps-tone-mapping.ps][float][vignetteAmount]    = min -1.0        max 1.0                default 0.0 \n"
    "[ps-tone-mapping.ps][float][blueShift]         = min 0.0         max 10.0               default 10.0 \n"
    "[ps-tone-mapping.ps][rgba][fogColor]           = min 0 0 0 0     max 255 255 255 255    default 255 255 255 255 \n",
    // Tone Mapping **********************

    // Toon **********************
    "toon.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float levels;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec4 color)\n"
    "{\n"
    "   int result;\n"
    "\n"
    "   color.xyz /= color.w;\n"
    "   result = int(floor(levels));\n"
    "   color.xyz *= float(result);\n"
    "   color.xyz = floor(color.xyz);\n"
    "   color.xyz /= float(result);\n"
    "   color.xyz *= color.w;\n"
    "   return color;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   if(color.a == 0.0)\n"
    "      discard;\n"
    "   else\n"
    "      gl_FragColor = xlat_main(color);\n"
    "}\n",

    "[ps-toon.ps] = toon.ps\n"
    "[ps-toon.ps][float][levels]         = min 0.0         max 15.0               default 5.0 \n",
    // Toon **********************

    // Fade **********************
    "fade.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float progress;\n"
    "uniform sampler2D sample0;\n"
    "uniform sampler2D sample1;\n"
    "\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 fade(vec4 c2)\n"
    "{\n"
    "   vec4 c1 = texture2D(sample1, vTexCoord);\n"
    "   return mix(c1, c2, vec4(progress/100.0));\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color0 = texture2D(sample0, vTexCoord);\n"
    "   gl_FragColor = fade(color0);\n"
    "}\n",

    "[ps-fade.ps] = fade.ps\n"
    "[ps-fade.ps][float][progress]         = min 0.0         max 100.0               default 30.0 \n",
    // Fade **********************

    // Fade Radial **********************
    "fade radial.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float progress;\n"
    "uniform sampler2D sample0;\n"
    "uniform sampler2D sample1;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 RadialBlur(in vec4 color, in float progress, in vec2 uv)\n"
    "{\n"
    "   vec2 center = vec2(0.500000, 0.500000);\n"
    "   vec2 toUV;\n"
    "   vec2 normToUV;\n"
    "   vec4 c1 = vec4(0.000000, 0.000000, 0.000000, 0.000000);\n"
    "   float s;\n"
    "   int i = 0;\n"
    "\n"
    "   toUV = (uv - center);\n"
    "   normToUV = toUV;\n"
    "   s = (progress * 0.0200000);\n"
    "   for (; (i < 24); (++i))\n"
    "   {\n"
    "       c1 += texture2D(sample1, (uv - ((normToUV * s) * float(i))));\n"
    "   }\n"
    "   c1 /= 24.0000;\n"
    "   return mix(c1, color, vec4(progress));\n"
    "}\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec4 color;\n"
    "\n"
    "   color = texture2D(sample0, uv);\n"
    "   if ((color.w == 0.000000))\n"
    "   {\n"
    "       return color;\n"
    "   }\n"
    "   return RadialBlur(color, (progress / 100.000), uv);\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n",

    "[ps-fade-radial.ps] = fade radial.ps\n"
    "[ps-fade-radial.ps][float][progress]         = min 0.0         max 100.0               default 30.0 \n",
    // Fade Radial **********************

    // Fade Ripple **********************
    "fade ripple.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float progress;\n"
    "uniform sampler2D sample0;\n"
    "uniform sampler2D sample1;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 Ripple(in float progress, in vec2 uv)\n"
    "{\n"
    "   float frequency = 20.0000;\n"
    "   float speed = 10.0000;\n"
    "   float amplitude = 0.0500000;\n"
    "   vec2 center = vec2(0.500000, 0.500000);\n"
    "   vec2 toUV;\n"
    "   float distanceFromCenter;\n"
    "   vec2 normToUV;\n"
    "   float wave;\n"
    "   float offset1;\n"
    "   float offset2;\n"
    "   vec2 newUV1;\n"
    "   vec2 newUV2;\n"
    "   vec4 c1;\n"
    "   vec4 c2;\n"
    "\n"
    "   toUV = (uv - center);\n"
    "   distanceFromCenter = length(toUV);\n"
    "   normToUV = (toUV / distanceFromCenter);\n"
    "   wave = cos(((frequency * distanceFromCenter) - (speed * progress)));\n"
    "   offset1 = ((progress * wave) * amplitude);\n"
    "   offset2 = (((1.00000 - progress) * wave) * amplitude);\n"
    "   newUV1 = (center + (normToUV * (distanceFromCenter + offset1)));\n"
    "   newUV2 = (center + (normToUV * (distanceFromCenter + offset2)));\n"
    "   c1 = texture2D(sample1, newUV1);\n"
    "   c2 = texture2D(sample0, newUV2);\n"
    "   return mix(c1, c2, vec4(progress));\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   gl_FragColor = Ripple((progress / 100.000), vTexCoord);\n"
    "}\n",

    "[ps-fade-ripple.ps] = fade ripple.ps\n"
    "[ps-fade-ripple.ps][float][progress]         = min 0.0         max 100.0               default 30.0 \n",
    // Fade Ripple **********************

    // Fade Saturate **********************
    "fade saturate.ps",

    "precision mediump float;\n"
    "uniform float progress;\n"
    "uniform sampler2D sample0;\n"
    "uniform sampler2D sample1;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_lib_saturate(vec4 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec4 Saturate(in vec2 uv, in float progress, in vec4 c2)\n"
    "{\n"
    "   vec4 c1;\n"
    "   float new_progress;\n"
    "\n"
    "   c1 = texture2D(sample1, uv);\n"
    "   c1 = xlat_lib_saturate((c1 * ((2.00000 * progress) + 1.00000)));\n"
    "   if ((progress > 0.800000))\n"
    "   {\n"
    "       new_progress = ((progress - 0.800000) * 5.00000);\n"
    "       return mix(c1, c2, vec4(new_progress));\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       return c1;\n"
    "   }\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   gl_FragColor = Saturate(vTexCoord, (progress / 100.000), color);\n"
    "\n"
    "}\n",

    "[ps-fade-saturate.ps] = fade saturate.ps\n"
    "[ps-fade-saturate.ps][float][progress]         = min 0.0         max 100.0               default 30.0 \n",
    // Fade Saturate **********************

    // Fade Twist **********************
    "fade twist.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float progress;\n"
    "uniform sampler2D sample0;\n"
    "uniform sampler2D sample1;\n"
    "uniform float twistAmount;\n"
    "varying vec2 vTexCoord;\n"
    "void xlat_lib_sincos(float x, out float s, out float c)\n"
    "{\n"
    "   s = sin(x);\n"
    "   c = cos(x);\n"
    "}\n"
    "\n"
    "vec2 xlat_lib_saturate(vec2 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec4 SampleWithBorder(in vec4 border, in sampler2D tex, in vec2 uv)\n"
    "{\n"
    "\n"
    "   if (any(bvec2((xlat_lib_saturate(uv) - uv))))\n"
    "   {\n"
    "       return border;\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       return texture2D(tex, uv);\n"
    "   }\n"
    "}\n"
    "\n"
    "vec4 Swirl(in vec2 uv, in float progress, in vec4 color)\n"
    "{\n"
    "   vec2 center = vec2(0.500000, 0.500000);\n"
    "   vec2 toUV;\n"
    "   float distanceFromCenter;\n"
    "   vec2 normToUV;\n"
    "   float angle;\n"
    "   vec2 newUV;\n"
    "   vec4 c1;\n"
    "\n"
    "   toUV = (uv - center);\n"
    "   distanceFromCenter = length(toUV);\n"
    "   normToUV = (toUV / distanceFromCenter);\n"
    "   angle = atan(normToUV.y, normToUV.x);\n"
    "   angle += (((distanceFromCenter * distanceFromCenter) * twistAmount) * progress);\n"
    "   xlat_lib_sincos(angle, newUV.y, newUV.x);\n"
    "   newUV *= distanceFromCenter;\n"
    "   newUV += center;\n"
    "   c1 = SampleWithBorder(vec4(0.000000, 0.000000, 0.000000, 0.000000), sample1, newUV);\n"
    "   return mix(c1, color, vec4(progress));\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   gl_FragColor = Swirl(vTexCoord, (progress / 100.000), color);\n"
    "}\n",

    "[ps-fade-twist.ps] = fade twist.ps\n"
    "[ps-fade-twist.ps][float][progress]         = min 0.0         max 100.0               default 30.0 \n"
    "[ps-fade-twist.ps][float][twistAmount]      = min -70.0       max 70.0                default 30.0 \n",
    // Fade Twist **********************

    // Fade Twist Grid **********************
    "fade twist grid.ps",

    "precision mediump float;\n"
    "\n"
    "uniform sampler2D sample0;\n"
    "uniform sampler2D sample1;\n"
    "uniform float progress;\n"
    "uniform float twistAmount;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "void xlat_lib_sincos(float x, out float s, out float c)\n"
    "{\n"
    "   s = sin(x);\n"
    "   c = cos(x);\n"
    "}\n"
    "\n"
    "vec4 SwirlGrid(in vec2 uv, in float progress, in vec4 color)\n"
    "{\n"
    "   float cellsize = 0.100000;\n"
    "   vec2 cell;\n"
    "   vec2 oddeven;\n"
    "   float cellTwistAmount;\n"
    "   vec2 newUV;\n"
    "   vec2 center = vec2(0.500000, 0.500000);\n"
    "   vec2 toUV;\n"
    "   float distanceFromCenter;\n"
    "   vec2 normToUV;\n"
    "   float angle;\n"
    "   vec2 newUV2;\n"
    "   vec4 c1;\n"
    "\n"
    "   cell = floor((uv * 10.0000));\n"
    "   oddeven = mod(cell, vec2(2.00000));\n"
    "   cellTwistAmount = twistAmount;\n"
    "   if ((oddeven.x < 1.00000))\n"
    "   {\n"
    "       cellTwistAmount *= -1.00000;\n"
    "   }\n"
    "   if ((oddeven.y < 1.00000))\n"
    "   {\n"
    "       cellTwistAmount *= -1.00000;\n"
    "   }\n"
    "   newUV = fract((uv * 10.0000));\n"
    "   toUV = (newUV - center);\n"
    "   distanceFromCenter = length(toUV);\n"
    "   normToUV = (toUV / distanceFromCenter);\n"
    "   angle = atan(normToUV.y, normToUV.x);\n"
    "   angle += (((distanceFromCenter * distanceFromCenter) * cellTwistAmount) * progress);\n"
    "   xlat_lib_sincos(angle, newUV2.y, newUV2.x);\n"
    "   newUV2 *= distanceFromCenter;\n"
    "   newUV2 += center;\n"
    "   newUV2 *= cellsize;\n"
    "   newUV2 += (cell * cellsize);\n"
    "   c1 = texture2D(sample1, newUV2);\n"
    "   return mix(c1, color, vec4(progress));\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   gl_FragColor = SwirlGrid(vTexCoord, (progress / 100.000), color);\n"
    "}\n",

    "[ps-fade-twist-grid.ps] = fade twist grid.ps\n"
    "[ps-fade-twist-grid.ps][float][progress]         = min 0.0         max 100.0               default 30.0 \n"
    "[ps-fade-twist-grid.ps][float][twistAmount]      = min -70.0       max 70.0                default 30.0 \n",
    // Fade Twist Grid **********************

    // Fade Wave **********************
    "fade wave.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float progress;\n"
    "uniform sampler2D sample0;\n"
    "uniform sampler2D sample1;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "\n"
    "vec2 xlat_lib_saturate(vec2 x)\n"
    "{\n"
    "   return clamp(x, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec4 SampleWithBorder(in vec4 border, in sampler2D tex, in vec2 uv)\n"
    "{\n"
    "\n"
    "   if (any(bvec2((xlat_lib_saturate(uv) - uv))))\n"
    "   {\n"
    "       return border;\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       return texture2D(tex, uv);\n"
    "   }\n"
    "}\n"
    "\n"
    "vec4 Wave(in vec2 uv, in float progress, in vec4 color)\n"
    "{\n"
    "   float mag = 0.100000;\n"
    "   float phase = 14.0000;\n"
    "   float freq = 20.0000;\n"
    "   vec2 newUV;\n"
    "   vec4 c1;\n"
    "\n"
    "   newUV = (uv + vec2(((mag * progress) * sin(((freq * uv.y) + (phase * progress)))), 0.000000));\n"
    "   c1 = SampleWithBorder(vec4(0.000000), sample1, newUV);\n"
    "   return mix(c1, color, vec4(progress));\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   gl_FragColor = Wave(vTexCoord, (progress / 100.000), color);\n"
    "}\n",

    "[ps-fade-wave.ps] = fade wave.ps\n"
    "[ps-fade-wave.ps][float][progress]         = min 0.0         max 100.0               default 30.0 \n",
    // Fade Wave **********************

    // Blur com Zoom **********************
    "blur zoom.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float blurAmount;\n"
    "uniform vec2 center;\n"
    "uniform sampler2D sample0;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   vec4 color;\n"
    "   vec4 c;\n"
    "   int i = 0;\n"
    "   float scale;\n"
    "\n"
    "   \n"
    "   c = vec4(0.000000);\n"
    "   uv -= center;\n"
    "   for (; (i < 15); (++i))\n"
    "   {\n"
    "       scale = (1.00000 + (blurAmount * (float(i) / 14.0000)));\n"
    "       c += texture2D(sample0, ((uv * scale) + center));\n"
    "   }\n"
    "   c /= 15.0000;\n"
    "   return c;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color = texture2D(sample0, vTexCoord);\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n",

    "[ps-blur-zoom.ps] = blur zoom.ps\n"
    "[ps-blur-zoom.ps][vector2][center]           = min 0.0 0.0     max 1.0 1.0             default 0.62 0.67 \n"
    "[ps-blur-zoom.ps][float][blurAmount]         = min 0.0         max 2.0                 default 0.2 \n",
    // Blur com Zoom **********************

    // Texture Map **********************
    "texture map.ps",

    "precision mediump float;\n"
    "\n"
    "uniform float horizontalOffset;\n"
    "uniform float horizontalSize;\n"
    "uniform sampler2D sample0;\n"
    "uniform sampler2D sample1;\n"
    "uniform float strength;\n"
    "uniform float verticalOffset;\n"
    "uniform float verticalSize;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec2 uv)\n"
    "{\n"
    "   float horzOffset;\n"
    "   float vOffset;\n"
    "   vec2 offset;\n"
    "   vec4 c1;\n"
    "\n"
    "   horzOffset = fract(((uv.x / horizontalSize) + min(1.00000, horizontalOffset)));\n"
    "   vOffset = fract(((uv.y / verticalSize) + min(1.00000, verticalOffset)));\n"
    "   offset = ((texture2D(sample1, vec2(horzOffset, vOffset)).xy * strength) - (strength / 8.00000));\n"
    "   c1 = texture2D(sample0, fract((uv + offset)));\n"
    "   return c1;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec4 color;\n"
    "   color = texture2D(sample0, vTexCoord);\n"
    "   gl_FragColor = xlat_main(vTexCoord);\n"
    "}\n",

    "[ps-texture-map.ps] = texture map.ps\n"
    "[ps-texture-map.ps][float][horizontalSize]       = min 0.0         max 5.0                 default 1.0 \n"
    "[ps-texture-map.ps][float][verticalSize]         = min 0.0         max 5.0                 default 1.0 \n"
    "[ps-texture-map.ps][float][horizontalOffset]     = min 0.0         max 1.0                 default 0.0 \n"
    "[ps-texture-map.ps][float][verticalOffset]       = min 0.0         max 1.0                 default 0.0 \n"
    "[ps-texture-map.ps][float][strength]             = min 0.0         max 1.0                 default 0.3 \n",
    // Texture Map **********************

    /* VERTEX SHADER
       -----------------------------------------------------------------------------------------------------*/

    // Textura Simples **********************
    "simple texture.vs",

    "precision highp float;\n"
    "uniform mat4 mvpMatrix;\n"
    "attribute vec4 aPosition;\n"
    "attribute vec4 aNormal;\n"
    "attribute vec2 aTextCoord;\n"
    "varying vec4 vPosition;\n"
    "varying vec4 vNormal;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vPosition   =   aPosition;\n"
    "   vNormal     =   aNormal;\n"
    "   vTexCoord   =   aTextCoord;\n"
    "   gl_Position =  (mvpMatrix * aPosition);\n"
    "}\n",

    "[vs-simple-texture.vs] = simple texture.vs\n",
    // Textura Simples **********************

    // Escala simples **********************
    "scale.vs",

    "precision highp float;\n"
    "uniform mat4 mvpMatrix;\n"
    "uniform vec3 scale;\n"
    "attribute vec4 aPosition;\n"
    "attribute vec4 aNormal;\n"
    "attribute vec2 aTextCoord;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "struct VS_OUTPUT\n"
    "{\n"
    "   vec4 pos;\n"
    "   vec2 uv;\n"
    "};\n"
    "\n"
    "\n"
    "VS_OUTPUT xlat_main(in vec4 pos, in vec4 nor, in vec2 uv)\n"
    "{\n"
    "   VS_OUTPUT ret;\n"
    "\n"
    "   pos.x *= scale.x;\n"
    "   pos.y *= scale.y;\n"
    "   pos.z *= scale.z;\n"
    "   ret.pos = (mvpMatrix * pos);\n"
    "   ret.uv = uv;\n"
    "   return ret;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   VS_OUTPUT ret;\n"
    "   ret = xlat_main(aPosition, aNormal, aTextCoord);\n"
    "   vTexCoord = ret.uv;\n"
    "   gl_Position = vec4(ret.pos);\n"
    "}\n"
    "\n",

    "[vs-scale.vs] = scale.vs\n"
    "[vs-scale.vs][vector3][scale]       = min 0.0 0.0 0.0         max 10.0  10.0 10.0                default 1.0 1.0 1.0\n",
    // Escala simples **********************
        /*
    // Escala Diff **********************
    "scale diff.vs",

    "precision highp float;\n"
    "\n"
    "uniform float height;\n"
    "uniform float maxHeight;\n"
    "uniform mat4 mvpMatrix;\n"
    "uniform float scale;\n"
    "attribute vec4 aPosition;\n"
    "attribute vec4 aNormal;\n"
    "attribute vec2 aTextCoord;\n"
    "varying vec4 vPosition;\n"
    "varying vec4 vNormal;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec4 pos)\n"
    "{\n"
    "   float num;\n"
    "   vec4 ret;\n"
    "\n"
    "   if ((pos.y > height))\n"
    "   {\n"
    "       num = (scale * (abs(pos.y) / maxHeight));\n"
    "       pos.x *= num;\n"
    "       pos.z *= num;\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       num = ((1.00000 - scale) * (1.00000 - (abs(pos.y) / maxHeight)));\n"
    "       pos.x *= num;\n"
    "       pos.z *= num;\n"
    "   }\n"
    "   ret = (mvpMatrix * pos);\n"
    "   return ret;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vPosition   =   xlat_main(aPosition);\n"
    "   vNormal     =   aNormal;\n"
    "   vTexCoord   =   aTextCoord;\n"
    "   gl_Position =   vPosition;\n"
    "}\n"
    "\n",

    "[vs-scale-diff.vs] = scale diff.vs\n"
    "[vs-scale-diff.vs][float][scale]       = min 0.0         max 3.0                 default 1.0 \n"
    "[vs-scale-diff.vs][float][height]      = min -100.0      max 100.0               default 0.0 \n"
    "[vs-scale-diff.vs][float][maxHeight]   = min -100.0      max 100.0               default 0.0 \n",
    // Escala Diff **********************

    // Escala Diff by Y **********************
    "scale diff by y.vs",

    "precision highp float;\n"
    "\n"
    "uniform float height;\n"
    "uniform float maxHeight;\n"
    "uniform mat4 mvpMatrix;\n"
    "uniform float scale;\n"
    "attribute vec4 aPosition;\n"
    "attribute vec4 aNormal;\n"
    "attribute vec2 aTextCoord;\n"
    "varying vec4 vPosition;\n"
    "varying vec4 vNormal;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "vec4 xlat_main(in vec4 pos)\n"
    "{\n"
    "   float num;\n"
    "   vec4 ret;\n"
    "\n"
    "   if ((pos.y > height))\n"
    "   {\n"
    "       num = (scale * (abs(pos.y) / maxHeight));\n"
    "       pos.y *= num;\n"
    "       pos.z *= num;\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       num = ((1.00000 - scale) * (1.00000 - (abs(pos.y) / maxHeight)));\n"
    "       pos.y *= num;\n"
    "       pos.z *= num;\n"
    "   }\n"
    "   ret = ( mvpMatrix * pos );\n"
    "   return ret;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vPosition   =   xlat_main(aPosition);\n"
    "   vNormal     =   aNormal;\n"
    "   vTexCoord   =   aTextCoord;\n"
    "   gl_Position =   vPosition;\n"
    "}\n"
    "\n",

    "[vs-scale-diff-by-y.vs] = scale diff by y.vs\n"
    "[vs-scale-diff-by-y.vs][float][scale]       = min 0.0         max 3.0                 default 1.0 \n"
    "[vs-scale-diff-by-y.vs][float][height]      = min -100.0      max 100.0               default 0.0 \n"
    "[vs-scale-diff-by-y.vs][float][maxHeight]   = min -100.0      max 100.0               default 0.0 \n",
    // Escala Diff by Y **********************



    // Fluttering **********************
    "fluttering.vs",

    "precision highp float;\n"
    "\n"
    "uniform float deepth;\n"
    "uniform mat4 mvpMatrix;\n"
    "uniform float wave;\n"
    "\n"
    "attribute vec4 aPosition;\n"
    "attribute vec4 aNormal;\n"
    "attribute vec2 aTextCoord;\n"
    "\n"
    "varying vec4 vPosition;\n"
    "varying vec4 vNormal;\n"
    "varying vec2 vTexCoord;\n"
    "\n"
    "\n"
    "vec4 xlat_main(in vec4 pos, in vec4 nor)\n"
    "{\n"
    "   float rest = (wave/360.0);\n"
    "   float angle = rest * 2.0;\n"
    "   pos.z = sin((pos.x + angle));\n"
    "   pos.z += sin(((pos.y / 2.00000) + angle));\n"
    "   pos.z *= ((pos.x * 0.0900000) + (nor.z * deepth));\n"
    "   pos = (pos + (mvpMatrix * pos));\n"
    "   return pos;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vPosition = xlat_main(aPosition, aNormal);\n"
    "   vNormal = aNormal;\n"
    "   vTexCoord = aTextCoord;\n"
    "   gl_Position = vPosition;\n"
    "}\n",

    "[vs-fluttering.vs] = fluttering.vs\n"
    "[vs-fluttering.vs][float][wave]       = min 0.0         max 1.0                 default 1.0 \n"
    "[vs-fluttering.vs][float][deepth]     = min 0.0         max 10.0                default 1.0 \n",
    // Fluttering **********************
    */

    nullptr, nullptr, nullptr};
}

#endif
